)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet() %>%
setView(lng = 7, lat = 51, zoom = 20) %>%
addProviderTiles(providers$Stamen.TonerLite,
options = providerTileOptions(noWrap = TRUE)
)
})
}
shinyApp(ui, server)
library(shiny)
library(leaflet)
ui <- fluidPage(
leafletOutput("mymap"),
)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet() %>%
setView(lng = 7, lat = 51, zoom = 14) %>%
addProviderTiles(providers$Stamen.TonerLite,
options = providerTileOptions(noWrap = TRUE)
)
})
}
shinyApp(ui, server)
library(leaflet)
ui <- fluidPage(
leafletOutput("mymap"),
)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet() %>%
setView(lng = 7, lat = 51, zoom = 11) %>%
addProviderTiles(providers$Stamen.TonerLite,
options = providerTileOptions(noWrap = TRUE)
)
})
}
shinyApp(ui, server)
m[i]
m <- list()
for(i in 1:1000){
prob <- runif(1, min = 0, max = 1)
m[i] <- rbinom(1000, 50, prob)
i <- i + 1
}
m[i]
Sys.setenv( MY_API='4442c8a4077bb52da19a77c4fa41f5f5')
Sys.getenv("MY_API")
## Example for getWeather ##
getWeather("Berlin, Deutschland", Sys.getenv("MY_API"))
library(httr)
library(jsonlite)
library(dplyr)
library(leaflet)
library(mapview)
library(magick)
library(tidygeocoder)
# tidygeocoder::geo_osm() uses a string with an address as input and returns
# the latitude and longitude of the location.
# You will need an API key to access the data from openweathermaps.org
# you have to sign up for a free account to get the api key
# the api key is private and should not be shared with other people
myApiKey <- "insert your api key here"
# The following function takes the location (in string format) and your apiKey (in string format) as input.
# The function returns the weather data for a specific location as a list.
# The weather data are provided by www.openweathermap.org
getWeather <- function(location, apiKey){
# first, we need to use tidygeocoder::geo_osm to get the longitude and the latitude of the desired location.
latitude <- tidygeocoder::geo_osm(location)$lat[1]
longitude <- tidygeocoder::geo_osm(location)$long[1]
# now, we access www.openweatherapp.org and retrieve the weather data.
myurl <- paste0("https://api.openweathermap.org/data/2.5/onecall?lat=", latitude, "&lon=", longitude,
"&exclude=FALSE&appid=", apiKey)
# the data are in JSON format, they have to be transformed before we can use them.
myRawResults <- httr::GET(myurl)
mycontent <- httr::content(myRawResults, as = "text")
myContentFromJson <- jsonlite::fromJSON(mycontent)
return(myContentFromJson)
}
## Example for getWeather ##
getWeather("Berlin, Deutschland", Sys.getenv("MY_API"))
## Example for getWeather ##
getWeather("Amsterdam, Niederlande", Sys.getenv("MY_API"))
sys.get("MY_API")
is.string(sys.getenv("MY_API"))
m <- matrix(1:10, 2,5)
m
vecotor <- matrix()
m <- matrix(1:10, 2,5)
vecotor <- matrix()
for(i in 1:nrow(m)){
for(j in 2:ncol(m)){
vector[i,1] <- m[i,1]
vector[i,j] <- vector [i, j-1] + m[i,j]
}
}
m[1,1]
m <- matrix(1:10, 2,5)
vecotor <- matrix()
for(i in 1:nrow(m)){
for(j in 2:ncol(m)){
vector[i,1] <- m[i,1]
vector[i,j] <- vector [i, j-1] + m[i,j]
j <- j + 1
}
i <- i + 1
}
nrow(m)
m <- matrix(1:10, 2,5)
vecotor <- matrix()
nrow(m)
ncol(m)
for(i in 1:nrow(m)){
for(j in 2:ncol(m)){
vector[i,1] <- m[i,1]
vector[i,j] <- vector [i, j-1] + m[i,j]
j <- j + 1
}
i <- i + 1
}
vector <- matrix()
vector <- NULL
vector <- data.frame()
m <- matrix(1:10, 2,5)
vector <- data.frame()
for(i in 1:nrow(m)){
for(j in 2:ncol(m)){
vector[i,1] <- m[i,1]
vector[i,j] <- vector [i, j-1] + m[i,j]
j <- j + 1
}
i <- i + 1
}
vector
m
Sys.setenv( MY_API='4442c8a4077bb52da19a77c4fa41f5f5')
devtools::install_github("Programming-The-Next-Step/weather_app/weatherApp", ref = "Functions-for-RPackage")
shiny::runApp('GitHub/weather_app')
install.packages("tidyverse")
foodField <- gen_Field_Pos(field, nFood)
library(tidyverse)
library(ggplot2)
library(reshape2)
gen_Field_Pos <- function (field, n) {
FieldPos <- sample(1:length(field), size = n)
field[FieldPos] <- TRUE
return(field)
}
gen_Img_Dat <- function(foodField, agentField, field) {
fInd <- which(!is.na(foodField))
aInd <- which(!is.na(agentField))
faInd <- intersect(fInd, aInd)
imgDat <- c(rep(field, 3))
dim(imgDat) <- c(nrow, ncol, 3)
imgDat[,,1][fInd] <- "Food"
imgDat[,,2][aInd] <- "Agent"
imgDat[,,3][faInd] <- "Agent on Food"
imgDat <-melt(imgDat)[-3]
imgDat <-imgDat[is.na(imgDat$value) == FALSE,]
return(imgDat)
}
gen_Img_Plot <- function(imgDat) {
ggplot() +
scale_x_continuous() + scale_y_continuous() + coord_fixed() + #to ensure that the scale does not change
scale_fill_identity() + scale_size_identity() + scale_shape_identity() +
geom_rect(aes(xmin = -0.5, xmax = ncol + 0.5, ymin = -0.5, ymax = nrow + 0.5,
fill = c("antiquewhite2")), color = "black", alpha = 1) + # black outer square
#food is treated different from agents in that it affects the raster/terrain
geom_raster(data = imgDat[imgDat["value"] == "Food", ],
mapping = aes(x = Var1, y = Var2, fill = "green2")) +
geom_point(data = imgDat[imgDat["value"] == "Agent",],
mapping = aes(x = Var1, y = Var2, shape = c(rep(21, length(Var1)))),
size=20,fill="red") +
geom_point(data = imgDat[imgDat["value"] == "Agent on Food", ],
mapping = aes(x = Var1, y = Var2, shape = c(rep(21, length(Var1)))), size = 20, fill = "yellow") +
labs(x = paste("X (0 -",ncol,")"), y = paste("Y (0 -",nrow,")"), title = t)
}
meta_Data <- function() {
df <- data.frame(Time_Point = t, Food_Total = nFood, Agent_Total = nAgent,
Ratio_F_by_A = c(nFood/nAgent), Ratio_F_by_Total = nFood/length(field),
Born = born, Died = died)
return(df)
}
sense_Food <- function(Individual) {
if (dim(intersect(foodCoord["ind"], agentCoord["ind"]))[1] > 0) {
senseInd <- intersect(foodCoord["ind"], agentCoord["ind"])[[1]]
Individual[Individual[["ind"]] %in% senseInd,"sense"] <- 1
}
return(Individual)
}
eat_Food <- function(Individual) {
if (exists("priorIndividual")) {
if (length(priorIndividual) > 0 & dim(priorIndividual[priorIndividual["sense"] == 1,])[1] > 0) {
actID <- as.vector(priorIndividual[priorIndividual["sense"] == 1 & priorIndividual["fitness"] != "vanished", "ID"])
Individual[Individual[["ID"]] %in% actID, "action"] <- 1
nFood <- nFood - sum(priorIndividual["action"] > 0)
foodField[as.vector(Individual[Individual["action"] == 1, "ind"])] <- NA
Population[Population[["ID"]] %in% actID, "Food_Consumed"] <- Population[Population[["ID"]] %in% actID, "Food_Consumed"] + 1
}}
return(list(Individual = Individual, foodField = foodField, nFood = nFood, Population = Population))
}
calculate_Energy <- function(Individual) {
Individual[((Individual$row.d | Individual$col.d) > 0), "energy"] <- Individual[((Individual$row.d | Individual$col.d) > 0),"energy"] - 3
Individual[((Individual$row.d | Individual$col.d) == 0), "energy"] <- Individual[((Individual$row.d | Individual$col.d) == 0),"energy"] - 1
Individual[Individual["action"] == 1,"energy"] <- Individual[Individual["action"] == 1,"energy"] + 15
return(Individual)
}
categorise_Fitness <- function(Individual) {
if(any(Individual["energy"] > 45 | Individual["energy"] < -15)) {
Individual$fitness <- factor(Individual$fitness, levels = c("vanishing", "normal", "reproducing"))
Individual$fitness[Individual$energy < -15] <- "vanishing"
Individual$fitness[Individual$energy >= -15 & Individual$energy < 45] <- "normal"
Individual$fitness[Individual$energy >= 45] <- "reproducing"
}
return(Individual)
}
vanishing_Agents <- function(Individual) {
vanishID <- Individual[Individual["fitness"] == "vanishing","ID"]
vanishData <- Individual[Individual[["ID"]] %in% vanishID & Individual["t"]==t,]
vanishData <- data.frame(ID = vanishData[["ID"]], Death_Ind = vanishData[["ind"]], Death_t = vanishData[["t"]])
Population[Population[["ID"]] %in% vanishData[["ID"]],c("Death_Ind","Death_t")] <- vanishData[c("Death_Ind","Death_t")]
nAgent <- nAgent - nrow(vanishData)
agentField[vanishData[["Death_Ind"]]] <- NA
died <- died + nrow(vanishData)
return(list(Individual = Individual, Population = Population, nAgent = nAgent, agentField = agentField, died = died))
}
born_Agents <- function(Individual) {
parentIndividual <- Individual[Individual["fitness"] == "reproducing", ]
if (dim(parentIndividual)[1] > 0) {
parentIndividual[, "fitness"] <- "normal"
parentIndividual["energy"] <- 0
childId <- paste0("A", nrow(Population)+1:nrow(parentIndividual))
childIndividual <- data.frame(t = t, ID = childId, parentIndividual[-1:-2])
for(i in 1:nrow(childIndividual)) {
moveFieldChild <- matrix(NA, 3, 3)
moveFieldChild[c(sample(c(1:4, 6:9),1))] <- 1 #exclude 5 to avoid similar position as parent agent.
childIndividual[i, c("row.d","col.d")] <- which(moveFieldChild == 1, arr.ind = TRUE)
childIndividual[i, c("row.d","col.d")] <- childIndividual[i,c("row.d","col.d")] - c(2,2) #
}
childIndividual[, c("row","col")] <- childIndividual[, c("row","col")] + childIndividual[, c("row.d","col.d")]
childIndividual[, c("row","col")] <- cbind((childIndividual["row"] - 1) %% nrow + 1, (childIndividual["col"] - 1) %% ncol + 1)
childIndividual["ind"] <- as.vector(apply(childIndividual[c("row","col")],1, function(x) indField[x[1],x[2]]))
Individual[Individual[["ID"]] %in% parentIndividual[["ID"]], ] <- parentIndividual
childPopulation <- data.frame(ID = childIndividual["ID"], Birth_Ind = childIndividual["ind"], Birth_t = t, Death_Ind = NA, Death_t = NA, Live_Duration = NA,Parent_ID = parentIndividual["ID"], Food_Consumed = 0)
Population <- rbind(Population, childPopulation)
Individual <- rbind(Individual, childIndividual)
nAgent <- nAgent + nrow(childIndividual)
born <- born + nrow(childIndividual)
}
Population <- Population
Individual <- Individual
nAgent <- nAgent
born <- born
return(list(Individual = Individual, Population = Population, nAgent = nAgent, born = born))
}
moving_Agents <- function(Individual) {
normalIndividual <- priorIndividual[priorIndividual["fitness"] == "normal", ]
if (dim(normalIndividual)[1] > 0) {
normalIndividual["t"] <- t
for(i in 1:nrow(normalIndividual)) {
moveField <- matrix(NA, 3, 3)
moveField[c(sample(c(1:9),1))] <- 1
normalIndividual[i, c("row.d","col.d")] <- which(moveField == 1, arr.ind = TRUE)
normalIndividual[i, c("row.d","col.d")] <- normalIndividual[i,c("row.d","col.d")] - c(2,2)
}
normalIndividual[, c("row","col")] <- normalIndividual[, c("row","col")] + normalIndividual[, c("row.d","col.d")]
normalIndividual[, c("row","col")] <- cbind((normalIndividual["row"] - 1) %% nrow + 1, (normalIndividual["col"] - 1) %% ncol + 1)
normalIndividual["ind"] <- as.vector(apply(normalIndividual[c("row","col")],1, function(x) indField[x[1],x[2]]))
Individual[Individual[["ID"]] %in% normalIndividual[["ID"]], ] <- normalIndividual
}
return(Individual)
}
distribute_Overlaying_Agents <- function (Individual) {
if(any(count(Individual, ind)[2] > 1)) {
while(any(count(Individual, ind)[2] > 1)) {
overlayed <- count(Individual, ind)[count(Individual, ind)[2] > 1,]
for (i in 1:nrow(overlayed)) {
overlayRows <- as.integer(row.names(Individual[Individual[["ind"]] == overlayed[[i,1]],]))[-1]
toMove <- Individual[overlayRows, ]
for (j in 1:length(overlayRows)) {
moveField <- matrix(NA, 3, 3)
moveField[c(sample(c(1:4, 6:9),1))] <- 1
toMove[j, c("row.d","col.d")] <- which(moveField == 1, arr.ind = TRUE)
toMove[j, c("row.d","col.d")] <- toMove[i,c("row.d","col.d")] - c(2,2)
toMove[j, c("row","col")] <- toMove[j, c("row","col")] + toMove[j, c("row.d","col.d")]
toMove[j, c("row","col")] <- cbind((toMove[j,"row"] - 1) %% nrow + 1, (toMove[j,"col"] - 1) %% ncol + 1)
toMove[j,"ind"] <- indField[toMove[j,"row"],toMove[j,"col"]]
}
Individual[Individual[["ID"]] %in% toMove[["ID"]], ] <- toMove
}
}
}
return(Individual)
}
Evo_Game <- function(nrow = 4, ncol = 4, nFood = 5, nAgent = 2, tick = 2) {
# Generating the data structure for the first time point plot and raw spatial information
field <- matrix(NA, nrow, ncol)
indField <- matrix(1:(ncol*nrow), nrow, ncol)
foodField <- gen_Field_Pos(field, nFood)
agentField <- gen_Field_Pos(field, nAgent)
agentField[!is.na(agentField)] <- c(1:nAgent) #arbitrary, could also just be TRUE but this way provides identity
# Set defaults for graph
t <- 0
born <- nAgent
died <- 0
nAgentTotal <- nAgent
# First image data and plot
imgDat <- gen_Img_Dat(foodField,agentField,field)
imgPlot <- gen_Img_Plot(imgDat)
# First output structures. They contain more general and spatial information and the graph.
metaData <- meta_Data()
foodCoord <- as.data.frame(cbind(which(!is.na(foodField), arr.ind = TRUE),
ind = which(!is.na(foodField))))
agentCoord <- data.frame(ID = paste0("A", 1:nAgent), as.data.frame(which(!is.na(agentField), arr.ind = TRUE)),
ind = which(!is.na(agentField)))
Time_Series <- list()
Time_Series[[paste0("t",t)]] <- list(Image_Plot = imgPlot, Data_Plot = imgDat, Agent_Coordinates = agentCoord,
Food_Coordinates = foodCoord, Meta_Data = metaData)
#Both population and individual characteristics that depend on agent specific information.
#They are both adjusted due to an agents state changes during the interval.
Population <- data.frame(ID = paste0("A", 1:nAgent), Birth_Ind = agentCoord["ind"], Birth_t = t, Death_Ind = NA, Death_t = NA, Live_Duration = NA,Parent_ID = NA, Food_Consumed = 0)
Entire_Individual <- data.frame()
Individual <- data.frame(t = t, agentCoord, row.d = 0, col.d = 0, sense = 0, action = 0, energy = 0, fitness = as.factor("normal"))
#Now the first state change phase takes place: Sensing, eating(or action), energy level change and finally fitness category evaluation.
#How many intervals is determined by the integer "tick"
for (i in 1:tick) {
if(dim(Individual)[1] > 0) { # To prevent errors due to all agents dying
#Sensing
Individual <- sense_Food(Individual)
#Eating
foodList <- eat_Food(Individual)
Individual <- foodList$Individual
nFood <- foodList$nFood
foodField <- foodList$foodField
Population <- foodList$Population
#Calculate energy and determine fitness state
Individual <- calculate_Energy(Individual)
Individual <- categorise_Fitness(Individual)
#Before finalising Population and Individual for this time point,
#We declare dead agents and delete their entries in the spatial indices.
vanishedList <- vanishing_Agents(Individual)
Individual <- vanishedList$Individual
Population <- vanishedList$Population
nAgent <- vanishedList$nAgent
agentField <- vanishedList$agentField
died <- vanishedList$died
Entire_Individual <- rbind(Entire_Individual,Individual)
Individual <- Individual[Individual["fitness"]!= "vanishing",]
}
#Finished interval t, next time point
t <- t + 1
if(dim(Individual)[1] > 0) { # again, to not cause errors if no agent is still alive.
priorIndividual <- Individual
Individual["t"] <- t
#New born agents are now declared.
bornList <- born_Agents(Individual)
Individual <- bornList$Individual
Population <- bornList$Population
nAgent <- bornList$nAgent
born <- bornList$born
#Movement takes place of the other agents
Individual <- moving_Agents(Individual)
#Depending on the order of birth, similar occupation of spaces in agents is resolved and the lower agent has to move
Individual <- distribute_Overlaying_Agents(Individual)
#Computing the plot again
agentField <- field
agentField[Individual[["ind"]]] <- as.integer(row.names(Individual))
imgDat <- gen_Img_Dat(foodField,agentField,field)
imgPlot <- gen_Img_Plot(imgDat)
# Output structure for the current time point is created (accounting for possible food or agent depletion)
metaData <- meta_Data()
if(max(!is.na(foodField)) > 0) {
foodCoord <- as.data.frame(cbind(which(!is.na(foodField), arr.ind = TRUE),
ind = which(!is.na(foodField))))
} else {
foodCoord <- NA
}
if(max(!is.na(agentField)) > 0) {
agentCoord <- Individual[c("ID","row","col","ind")]
} else {
agentCoord <- NA
}
Time_Series[[paste0("t",t)]] <- list(Image_Plot = imgPlot, Data_Plot = imgDat, Agent_Coordinates = agentCoord, Food_Coordinates = foodCoord, Meta_Data = metaData)
} else {
Time_Series[[paste0("t",t)]] <- NA
}
}
# Last dataframe update of the list of individuals that did not get the chance for sensing, action, and energy update
if(dim(Individual)[1] > 0) {
Entire_Individual <- rbind(Entire_Individual,Individual)
}
# Return of a list containing a list of spatial data per time point, and dataframes for the entire population and Individual
# status at a given time point
return(list(Time_Series, Population, Entire_Individual))
}
Evo_Game()
Evo_Game <- function(nrow = 4, ncol = 4, nFood = 5, nAgent = 2, tick = 2) {
# Generating the data structure for the first time point plot and raw spatial information
field <- matrix(NA, nrow, ncol)
indField <- matrix(1:(ncol*nrow), nrow, ncol)
foodField <- gen_Field_Pos(field, nFood)
agentField <- gen_Field_Pos(field, nAgent)
agentField[!is.na(agentField)] <- c(1:nAgent) #arbitrary, could also just be TRUE but this way provides identity
# Set defaults for graph
t <- 0
born <- nAgent
died <- 0
nAgentTotal <- nAgent
# First image data and plot
imgDat <- gen_Img_Dat(foodField,agentField,field)
imgPlot <- gen_Img_Plot(imgDat)
# First output structures. They contain more general and spatial information and the graph.
metaData <- meta_Data()
foodCoord <- as.data.frame(cbind(which(!is.na(foodField), arr.ind = TRUE),
ind = which(!is.na(foodField))))
agentCoord <- data.frame(ID = paste0("A", 1:nAgent), as.data.frame(which(!is.na(agentField), arr.ind = TRUE)),
ind = which(!is.na(agentField)))
Time_Series <- list()
Time_Series[[paste0("t",t)]] <- list(Image_Plot = imgPlot, Data_Plot = imgDat, Agent_Coordinates = agentCoord,
Food_Coordinates = foodCoord, Meta_Data = metaData)
#Both population and individual characteristics that depend on agent specific information.
#They are both adjusted due to an agents state changes during the interval.
Population <- data.frame(ID = paste0("A", 1:nAgent), Birth_Ind = agentCoord["ind"], Birth_t = t, Death_Ind = NA, Death_t = NA, Live_Duration = NA,Parent_ID = NA, Food_Consumed = 0)
Entire_Individual <- data.frame()
Individual <- data.frame(t = t, agentCoord, row.d = 0, col.d = 0, sense = 0, action = 0, energy = 0, fitness = as.factor("normal"))
#Now the first state change phase takes place: Sensing, eating(or action), energy level change and finally fitness category evaluation.
#How many intervals is determined by the integer "tick"
for (i in 1:tick) {
if(dim(Individual)[1] > 0) { # To prevent errors due to all agents dying
#Sensing
Individual <- sense_Food(Individual)
#Eating
foodList <- eat_Food(Individual)
Individual <- foodList$Individual
nFood <- foodList$nFood
foodField <- foodList$foodField
Population <- foodList$Population
#Calculate energy and determine fitness state
Individual <- calculate_Energy(Individual)
Individual <- categorise_Fitness(Individual)
#Before finalising Population and Individual for this time point,
#We declare dead agents and delete their entries in the spatial indices.
vanishedList <- vanishing_Agents(Individual)
Individual <- vanishedList$Individual
Population <- vanishedList$Population
nAgent <- vanishedList$nAgent
agentField <- vanishedList$agentField
died <- vanishedList$died
Entire_Individual <- rbind(Entire_Individual,Individual)
Individual <- Individual[Individual["fitness"]!= "vanishing",]
}
#Finished interval t, next time point
t <- t + 1
if(dim(Individual)[1] > 0) { # again, to not cause errors if no agent is still alive.
priorIndividual <- Individual
Individual["t"] <- t
#New born agents are now declared.
bornList <- born_Agents(Individual)
Individual <- bornList$Individual
Population <- bornList$Population
nAgent <- bornList$nAgent
born <- bornList$born
#Movement takes place of the other agents
Individual <- moving_Agents(Individual)
#Depending on the order of birth, similar occupation of spaces in agents is resolved and the lower agent has to move
Individual <- distribute_Overlaying_Agents(Individual)
#Computing the plot again
agentField <- field
agentField[Individual[["ind"]]] <- as.integer(row.names(Individual))
imgDat <- gen_Img_Dat(foodField,agentField,field)
imgPlot <- gen_Img_Plot(imgDat)
# Output structure for the current time point is created (accounting for possible food or agent depletion)
metaData <- meta_Data()
if(max(!is.na(foodField)) > 0) {
foodCoord <- as.data.frame(cbind(which(!is.na(foodField), arr.ind = TRUE),
ind = which(!is.na(foodField))))
} else {
foodCoord <- NA
}
if(max(!is.na(agentField)) > 0) {
agentCoord <- Individual[c("ID","row","col","ind")]
} else {
agentCoord <- NA
}
Time_Series[[paste0("t",t)]] <- list(Image_Plot = imgPlot, Data_Plot = imgDat, Agent_Coordinates = agentCoord, Food_Coordinates = foodCoord, Meta_Data = metaData)
} else {
Time_Series[[paste0("t",t)]] <- NA
}
}
# Last dataframe update of the list of individuals that did not get the chance for sensing, action, and energy update
if(dim(Individual)[1] > 0) {
Entire_Individual <- rbind(Entire_Individual,Individual)
}
# Return of a list containing a list of spatial data per time point, and dataframes for the entire population and Individual
# status at a given time point
return(list(Time_Series, Population, Entire_Individual))
}
Evo_Game()
setwd("~/UvA/1. Programming - Next Step/app.R versuch 2")
shiny::runApp('~/GitHub/weather_app')
setwd("~/GitHub/weather_app")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
